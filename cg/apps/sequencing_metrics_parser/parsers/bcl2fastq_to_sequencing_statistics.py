from datetime import datetime
from typing import List

from cg.apps.sequencing_metrics_parser.models.bcl2fastq_metrics import (
    Bcl2FastqSequencingMetrics,
    ConversionResult,
    DemuxResult,
)
from cg.apps.sequencing_metrics_parser.parsers.bcl2fastq import parse_bcl2fastq_sequencing_metrics
from cg.apps.sequencing_metrics_parser.sequencing_metrics_calculator import (
    q30_ratio,
    average_quality_score,
    yield_in_megabases,
    pass_filter_ratio,
    perfect_reads_ratio,
    average_clusters_per_lane,
)
from cg.store.models import SequencingStatistics


def get_sequencing_metrics_from_bcl2fastq(stats_json_path: str):
    """Create SequencingStatistics from the stats.json file generated by Bcl2fastq."""

    raw_sequencing_metrics: Bcl2FastqSequencingMetrics = parse_bcl2fastq_sequencing_metrics(
        stats_json_path=stats_json_path
    )

    sequencing_statistics: List[SequencingStatistics] = []

    for conversion_result in raw_sequencing_metrics.conversion_results:
        yield_in_megabases: int = calculate_lane_yield_in_megabases_from_conversion_result(
            conversion_result=conversion_result
        )

        passed_filter_percent: float = calculate_passed_filter_percent_from_conversion_result(
            conversion_result=conversion_result
        )

        for demux_result in conversion_result.demux_results:
            lanes_mean_quality_score: float = calculate_lane_mean_quality_score_from_demux_result(
                demux_result=demux_result
            )

            bases_with_q30_percent: float = calculate_bases_with_q30_percent_from_demux_result(
                demux_result=demux_result
            )

            perfect_index_reads_percent: float = (
                calculate_perfect_index_reads_percent_from_demux_result(demux_result=demux_result)
            )

            number_of_lanes: int = len(raw_sequencing_metrics.conversion_results)
            raw_clusters_per_lane_percent = average_clusters_per_lane(
                total_clusters=conversion_result.total_clusters_raw,
                lane_count=number_of_lanes,
            )

            statistics_for_sample_in_lane: SequencingStatistics = SequencingStatistics(
                flow_cell_name=raw_sequencing_metrics.flowcell,
                sample_internal_id=demux_result.sample_id,
                lane=conversion_result.lane_number,
                yield_in_megabases=yield_in_megabases,
                read_counts=demux_result.number_reads,
                passed_filter_percent=passed_filter_percent,
                raw_clusters_per_lane_percent=raw_clusters_per_lane_percent,
                perfect_index_reads_percent=perfect_index_reads_percent,
                bases_with_q30_percent=bases_with_q30_percent,
                lanes_mean_quality_score=lanes_mean_quality_score,
                started_at=datetime.now(),
            )

            sequencing_statistics.append(statistics_for_sample_in_lane)

    return sequencing_statistics


def calculate_perfect_index_reads_percent_from_demux_result(demux_result: DemuxResult):
    perfect_reads: int = sum(
        [metric.mismatch_counts.get("0", 0) for metric in demux_result.index_metrics]
    )
    sample_read_count_in_lane: int = demux_result.number_reads

    return perfect_reads_ratio(perfect_reads=perfect_reads, total_reads=sample_read_count_in_lane)


def calculate_bases_with_q30_percent_from_demux_result(demux_result: DemuxResult) -> float:
    yield_q30_total = sum([read.yield_q30 for read in demux_result.read_metrics])
    yield_total = sum([read.yield_ for read in demux_result.read_metrics])

    return q30_ratio(q30_yield=yield_q30_total, total_yield=yield_total)


def calculate_lane_mean_quality_score_from_demux_result(demux_result: DemuxResult) -> float:
    quality_score_sum_total = sum([read.quality_score_sum for read in demux_result.read_metrics])
    yield_total = sum([read.yield_ for read in demux_result.read_metrics])

    return average_quality_score(
        total_quality_score=quality_score_sum_total, total_yield=yield_total
    )


def calculate_lane_yield_in_megabases_from_conversion_result(
    conversion_result: ConversionResult,
) -> int:
    lane_yields_in_bases: List[int] = [demux.yield_ for demux in conversion_result.demux_results]
    total_lane_yield_in_bases: int = sum(lane_yields_in_bases)

    return yield_in_megabases(total_bases=total_lane_yield_in_bases)


def calculate_passed_filter_percent_from_conversion_result(
    conversion_result: ConversionResult,
) -> float:
    total_clusters_raw: int = conversion_result.total_clusters_raw
    total_clusters_pf: int = conversion_result.total_clusters_pf

    passed_filter_percent: float = pass_filter_ratio(
        total_clusters_pf=total_clusters_pf, total_clusters_raw=total_clusters_raw
    )

    return passed_filter_percent
