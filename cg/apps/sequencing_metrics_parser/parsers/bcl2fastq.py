import json
from typing import List

from cg.store.models import (
    SequencingStatistics,
)


def parse_bcl2fastq_metrics(demultiplexing_directory: str) -> List[SequencingStatistics]:
    """
    Parse the sequencing metrics for a flow cell demultiplexed using bcl2fastq.
    Args:
        demultiplexing_directory: Path to a directory with data from a flow cell demultiplexed with bcl2fastq
    """
    stats = parse_bcl2fastq_stats_json(demultiplexing_directory)
    pass


def parse_bcl2fastq_stats_json(stats_json_path: str):
    """Parse data of interest from the Stats.json file generated by bcl2fastq."""
    with open(stats_json_path) as f:
        data = json.load(f)

    number_of_lanes = get_number_of_lanes_from_stats(stats_data=data)

    for conversion_result in data["ConversionResults"]:
        for demux_result in conversion_result["DemuxResults"]:
            parse_demux_result(data["Flowcell"], conversion_result, demux_result, number_of_lanes)


def parse_demux_result(flow_cell_name, conversion_result, demux_result, num_lanes):
    """Parse data from a single demultiplexing result."""
    read_metrics = demux_result["ReadMetrics"]

    yield_q30_total = calculate_aggregate_yield_q30(read_metrics=read_metrics)
    yield_total = calculate_aggregate_yield(read_metrics=read_metrics)
    quality_score_sum_total = calculate_aggregate_quality_score_sum(read_metrics=read_metrics)

    sample_internal_id = demux_result["SampleId"]
    lane = conversion_result["LaneNumber"]
    yield_in_megabases = conversion_result["Yield"] // 1000000
    read_counts = demux_result["NumberReads"]
    passed_filter_percent = (
        conversion_result["TotalClustersPF"] / conversion_result["TotalClustersRaw"]
    )
    raw_clusters_per_lane_percent = conversion_result["TotalClustersRaw"] / num_lanes
    bases_with_q30_percent = yield_q30_total / yield_total
    lanes_mean_quality_score = quality_score_sum_total / yield_total

    return {
        "flow_cell_name": flow_cell_name,
        "sample_internal_id": sample_internal_id,
        "lane": lane,
        "yield_in_megabases": yield_in_megabases,
        "read_counts": read_counts,
        "passed_filter_percent": passed_filter_percent,
        "raw_clusters_per_lane_percent": raw_clusters_per_lane_percent,
        "bases_with_q30_percent": bases_with_q30_percent,
        "lanes_mean_quality_score": lanes_mean_quality_score,
    }


def get_number_of_lanes_from_stats(stats_data) -> int:
    return len(stats_data["ReadInfosForLanes"])


def calculate_aggregate_yield_q30(read_metrics):
    return sum(metric["YieldQ30"] for metric in read_metrics)


def calculate_aggregate_yield(read_metrics):
    return sum(metric["Yield"] for metric in read_metrics)


def calculate_aggregate_quality_score_sum(read_metrics):
    return sum(metric["QualityScoreSum"] for metric in read_metrics)
