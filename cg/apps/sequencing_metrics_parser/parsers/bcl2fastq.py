import json
from typing import List

from cg.store.models import (
    SequencingStatistics,
)


class SequencingMetricsCalculator:
    pass


class SequencingMetricsParser:
    pass


def parse_bcl2fastq_stats_json(stats_json_path: str) -> List[SequencingStatistics]:
    """Parse data of interest from the Stats.json file generated by bcl2fastq."""

    with open(stats_json_path) as f:
        data = json.load(f)

    number_of_lanes = get_number_of_lanes_from_stats(data)
    flow_cell_name = get_flow_cell_name(data)

    sequencing_statistics = []
    for conversion_result in data["ConversionResults"]:
        for lane_sample_demultiplexing_result in conversion_result["DemuxResults"]:
            statistics = create_sequencing_statistics(
                conversion_result,
                lane_sample_demultiplexing_result,
                number_of_lanes,
                flow_cell_name,
            )
            sequencing_statistics.append(statistics)

    return sequencing_statistics


def create_sequencing_statistics(
    conversion_result, lane_sample_demultiplexing_result, number_of_lanes, flow_cell_name
):
    sample_id = get_sample_id(lane_sample_demultiplexing_result)
    lane_number = get_lane_number(conversion_result)
    sample_lane_read_counts = get_number_of_reads_for_sample_in_lane(
        lane_sample_demultiplexing_result
    )

    lane_yield_in_bases = get_lane_yield_in_bases(conversion_result)
    yield_in_megabases = calculate_lane_yield_in_megabases(lane_yield_in_bases)

    total_clusters_passing_filter = get_total_clusters_passing_filter(conversion_result)
    total_raw_clusters = get_total_raw_clusters(conversion_result)

    passed_filter_percent = calculate_passed_filter_percent(
        total_clusters_passing_filter, total_raw_clusters
    )

    raw_clusters_per_lane_percent = calculate_raw_clusters_per_lane_percent(
        total_raw_clusters, number_of_lanes
    )

    lane_read_metrics = get_read_metrics(lane_sample_demultiplexing_result)
    lane_index_metrics = get_index_metrics(lane_sample_demultiplexing_result)

    lane_q30_yield_values = get_lane_yield_q30_values(lane_read_metrics)
    yield_q30_total = calculate_aggregate_yield_q30(lane_q30_yield_values)

    lane_yield_values = get_lane_yield_values(lane_read_metrics)
    total_lane_yield = calculate_aggregate_lane_yield(lane_yield_values)

    bases_with_q30_percent = calculate_bases_with_q30_percent(
        yield_q30_total=yield_q30_total, total_lane_yield=total_lane_yield
    )

    lane_quality_score_values = get_lane_read_quality_score_values(lane_read_metrics)
    lane_total_quality_score = calculate_aggregate_lane_read_quality_score(
        lane_quality_score_values
    )

    lanes_mean_quality_score = calculate_lanes_mean_quality_score(
        lane_total_quality_score, total_lane_yield
    )

    perfect_reads_for_sample_in_lane = get_perfect_reads_for_lane(lane_index_metrics)

    perfect_index_reads_percent = calculate_perfect_index_reads_percent(
        perfect_reads=perfect_reads_for_sample_in_lane, total_reads=sample_lane_read_counts
    )

    return SequencingStatistics(
        flow_cell_name=flow_cell_name,
        sample_internal_id=sample_id,
        lane=lane_number,
        sample_lane_read_counts=sample_lane_read_counts,
        yield_in_megabases=yield_in_megabases,
        passed_filter_percent=passed_filter_percent,
        raw_clusters_per_lane_percent=raw_clusters_per_lane_percent,
        bases_with_q30_percent=bases_with_q30_percent,
        lanes_mean_quality_score=lanes_mean_quality_score,
        perfect_index_reads_percent=perfect_index_reads_percent,
    )


def get_read_metrics(lane_sample_demultiplexing_result):
    """Extract the read metrics for a lane from a demultiplexing result."""
    return lane_sample_demultiplexing_result["ReadMetrics"]


def get_index_metrics(lane_sample_demultiplexing_result):
    """Extract the index metrics for a lane from a demultiplexing result."""
    return lane_sample_demultiplexing_result["IndexMetrics"][0]


def get_total_reads_for_lane(lane_sample_demultiplexing_result):
    """Extract the total number of reads for a lane from a demultiplexing result."""
    return lane_sample_demultiplexing_result["NumberReads"]


def get_number_of_lanes_from_stats(stats_data) -> int:
    """Extract the number of lanes from the stats data."""
    return len(stats_data["ReadInfosForLanes"])


def get_flow_cell_name(stats_data) -> str:
    """Extract the flow cell name from the stats data."""
    return stats_data["Flowcell"]


def get_sample_id(lane_sample_demultiplexing_result):
    """Extract the sample id from a demultiplexing result."""
    return lane_sample_demultiplexing_result["SampleId"]


def get_number_of_reads_for_sample_in_lane(lane_sample_demultiplexing_result):
    """Extract the number of reads for a sample in a lane."""
    return lane_sample_demultiplexing_result["NumberReads"]


def get_lane_number(conversion_result):
    """Extract the lane number from a conversion result."""
    return conversion_result["LaneNumber"]


def get_yield_q30(lane_read_metrics):
    """Extract the yield Q30 from the read metrics."""
    return lane_read_metrics["YieldQ30"]


def get_lane_yield_in_bases(conversion_result):
    """Extract the yield from the read metrics."""
    return conversion_result["Yield"]


def get_total_clusters_passing_filter(conversion_result):
    """Extract the total clusters passing the filter from the conversion result."""
    return conversion_result["TotalClustersPF"]


def get_total_raw_clusters(conversion_result):
    """Extract the total number of clusters initially generated, regardless of quality."""
    return conversion_result["TotalClustersRaw"]


def get_quality_score(read_metric):
    """Extract the sum of quality scores of all the bases from the read metrics."""
    return read_metric["QualityScoreSum"]


def get_lane_yield_q30_values(lane_read_metrics):
    """Extract the yield Q30 values for the lane from the read metrics."""
    return [get_yield_q30(metric) for metric in lane_read_metrics]


def get_lane_yield_values(lane_read_metrics):
    return [get_lane_yield_in_bases(metric) for metric in lane_read_metrics]


def get_lane_read_quality_score_values(lane_read_metrics):
    """Extract the quality score values for the lane from the read metrics."""
    return [get_quality_score(read_metric) for read_metric in lane_read_metrics]


def get_perfect_reads_for_lane(lane_index_metrics):
    """Extract the number of perfect reads for the lane from the read metrics."""
    counts = lane_index_metrics["MismatchCounts"]
    return int(counts.get("0", 0))


def calculate_aggregate_lane_read_quality_score(lane_read_quality_score_values):
    return sum(lane_read_quality_score_values)


def calculate_aggregate_yield_q30(lane_yield_q30_values):
    """Calculate the aggregated Q30 yield for the lane from its yield Q30 values."""
    return sum(lane_yield_q30_values)


def calculate_aggregate_lane_yield(lane_yield_values):
    """Calculate the aggregated yield for the lane from its yield values."""
    return sum(lane_yield_values)


def calculate_lane_yield_in_megabases(lane_yield_in_bases: int) -> int:
    """
    Calculate the lane yield in megabases.

    Args:
        lane_yield_in_bases (int): The total yield of the lane in bases.

    Returns:
        int: The yield in megabases.
    """
    return lane_yield_in_bases // 1000000


def calculate_passed_filter_percent(
    total_lane_clusters_pf: int, total_lane_clusters_raw: int
) -> float:
    """
    Calculate the passed filter percent for the lane.

    Args:
        total_lane_clusters_passing_filter (int): The total clusters passing the filter for the lane.
        total_lane_raw_clusters (int): The total number of clusters initially generated for the lane.

    Returns:
        float: The passed filter percent.
    """
    return total_lane_clusters_pf / total_lane_clusters_raw


def calculate_raw_clusters_per_lane_percent(total_raw_clusters: int, number_of_lanes: int) -> float:
    """
    Calculate the raw clusters per lane percent.

    Args:
        total_raw_clusters (int): The total number of clusters initially generated, regardless of quality.
        number_of_lanes (int): The total number of lanes.

    Returns:
        float: The raw clusters per lane percent.
    """
    return total_raw_clusters / number_of_lanes


def calculate_bases_with_q30_percent(yield_q30_total: int, yield_total: int) -> float:
    """
    Calculate the proportion of bases that have a Phred quality score of 30 or more for the lane.

    Args:
        yield_q30_total (int): The sum of all Q30 yields for samples in the lane.
        yield_total (int): The total yield for the lane.

    Returns:
        float: The proportion of bases with Q30 in the lane.
    """
    return yield_q30_total / yield_total


def calculate_lanes_mean_quality_score(quality_score_sum_total: int, yield_total: int) -> float:
    """
    Calculate the mean quality score of all the bases for the lane.

    Args:
        quality_score_sum_total (int): The aggregated quality score sum for the lane.
        yield_total (int): The total yield for the lane.
    Returns:
        float: The mean quality score of all the bases for the lane.
    """
    return quality_score_sum_total / yield_total


def calculate_perfect_index_reads_percent(perfect_reads: int, total_reads: int) -> float:
    """
    Calculate the perfect index reads percentage.

    Args:
        perfect_reads (int): The number of perfect reads for a sample in a lane.
        total_reads (int): The total number of reads for a sample in a lane.

    Returns:
        float: The perfect index reads percentage.
    """
    return (perfect_reads / total_reads) * 100
