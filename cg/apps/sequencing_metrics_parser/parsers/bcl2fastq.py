import json
from typing import List

from cg.store.models import (
    SequencingStatistics,
)


def parse_bcl2fastq_metrics(demultiplexing_directory: str) -> List[SequencingStatistics]:
    """
    Parse the sequencing metrics for a flow cell demultiplexed using bcl2fastq.
    Args:
        demultiplexing_directory: Path to a directory with data from a flow cell demultiplexed with bcl2fastq
    """
    stats = parse_bcl2fastq_stats_json(demultiplexing_directory)
    pass


def parse_bcl2fastq_stats_json(stats_json_path: str) -> List[SequencingStatistics]:
    """Parse data of interest from the Stats.json file generated by bcl2fastq."""

    sequencing_statistics = []

    with open(stats_json_path) as f:
        data = json.load(f)

    number_of_lanes = get_number_of_lanes_from_stats(data)
    flow_cell_name = get_flow_cell_name(data)

    for conversion_result in data["ConversionResults"]:
        for demux_result in conversion_result["DemuxResults"]:
            sample_id = get_sample_id(demux_result)
            lane_number = get_lane_number(conversion_result)
            read_counts = get_number_of_reads(demux_result)

            read_metrics = get_read_metrics(demux_result)

            quality_score_sum_total = calculate_aggregate_quality_score_sum(read_metrics)
            yield_in_megabases = calculate_yield_in_megabases(conversion_result)
            passed_filter_percent = calculate_passed_filter_percent(conversion_result)
            raw_clusters_per_lane_percent = calculate_raw_clusters_per_lane_percent(
                conversion_result, number_of_lanes
            )

            yield_q30_total = calculate_aggregate_yield_q30(read_metrics)
            yield_total = calculate_aggregate_yield(read_metrics)
            bases_with_q30_percent = yield_q30_total / yield_total
            lanes_mean_quality_score = quality_score_sum_total / yield_total

            statistics = SequencingStatistics(
                flow_cell_name=flow_cell_name,
                sample_internal_id=sample_id,
                lane=lane_number,
                read_counts=read_counts,
                yield_in_megabases=yield_in_megabases,
                passed_filter_percent=passed_filter_percent,
                raw_clusters_per_lane_percent=raw_clusters_per_lane_percent,
                bases_with_q30_percent=bases_with_q30_percent,
                lanes_mean_quality_score=lanes_mean_quality_score,
            )
            sequencing_statistics.append(statistics)

        return sequencing_statistics


def get_number_of_lanes_from_stats(stats_data) -> int:
    return len(stats_data["ReadInfosForLanes"])


def get_flow_cell_name(data) -> str:
    return data["Flowcell"]


def calculate_aggregate_yield_q30(read_metrics):
    return sum(metric["YieldQ30"] for metric in read_metrics)


def calculate_aggregate_yield(read_metrics):
    return sum(metric["Yield"] for metric in read_metrics)


def calculate_aggregate_quality_score_sum(read_metrics):
    return sum(metric["QualityScoreSum"] for metric in read_metrics)


def get_sample_id(demux_result):
    return demux_result["SampleId"]


def get_lane_number(conversion_result):
    return conversion_result["LaneNumber"]


def calculate_yield_in_megabases(conversion_result):
    return conversion_result["Yield"] // 1000000


def get_number_of_reads(demux_result):
    return demux_result["NumberReads"]


def calculate_passed_filter_percent(conversion_result):
    return conversion_result["TotalClustersPF"] / conversion_result["TotalClustersRaw"]


def calculate_raw_clusters_per_lane_percent(conversion_result, number_of_lanes):
    return conversion_result["TotalClustersRaw"] / number_of_lanes


def calculate_bases_with_q30_percent(conversion_result):
    return conversion_result["TotalYieldQ30"] / conversion_result["TotalYield"]


def get_read_metrics(demux_result):
    return demux_result["ReadMetrics"]
