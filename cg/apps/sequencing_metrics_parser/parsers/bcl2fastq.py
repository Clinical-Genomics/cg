from cg.io.json import read_json


class SequencingMetricsPerLaneAndSample:
    """
    Contains the parsed bcl2fastq sequencing metrics output.
    The data is parsed per lane and sample.
    """

    def __init__(self):
        self.number_of_lanes = 0
        self.flow_cell_name = ""
        self.lane_number = 0
        self.lane_yield_in_bases = 0
        self.total_clusters_passing_filter = 0
        self.total_raw_clusters = 0
        self.sample_id = ""
        self.sample_lane_read_counts = 0
        self.perfect_reads_for_sample_in_lane = 0
        self.lane_q30_yield_values = []
        self.lane_yield_values = []
        self.lane_quality_score_values = []


def parse_bcl2fastq_sequencing_metrics(stats_json_path):
    """Parse data of interest from the Stats.json file generated by bcl2fastq."""

    data = read_json(stats_json_path)

    parsed_metrics = []

    number_of_lanes = get_number_of_lanes_from_stats(data)
    flow_cell_name = get_flow_cell_name(data)

    for conversion_result in data["ConversionResults"]:
        metrics = SequencingMetricsPerLaneAndSample()

        metrics.flow_cell_name = flow_cell_name
        metrics.lane_number = get_lane_number(conversion_result)
        metrics.number_of_lanes = number_of_lanes
        metrics.lane_yield_in_bases = get_lane_yield_in_bases(conversion_result)
        metrics.total_clusters_passing_filter = get_total_clusters_passing_filter(conversion_result)
        metrics.total_raw_clusters = get_total_raw_clusters(conversion_result)

        for demux_result in conversion_result["DemuxResults"]:
            metrics.sample_id = get_sample_id(demux_result)
            metrics.sample_lane_read_counts = get_number_of_reads_for_sample_in_lane(demux_result)
            metrics.perfect_reads_for_sample_in_lane = get_perfect_reads_for_lane(demux_result)
            metrics.lane_q30_yield_values = get_lane_yield_q30_values(demux_result)
            metrics.lane_yield_values = get_lane_yield_values(demux_result)
            metrics.lane_quality_score_values = get_lane_read_quality_score_values(demux_result)

            parsed_metrics.append(metrics)

    return parsed_metrics


def get_read_metrics(demux_result):
    """Extract the read metrics for a lane from a demultiplexing result."""
    return demux_result["ReadMetrics"]


def get_index_metrics(demux_result):
    """Extract the index metrics for a lane from a demultiplexing result."""
    return demux_result["IndexMetrics"][0]


def get_number_of_lanes_from_stats(stats_data) -> int:
    """Extract the number of lanes from the stats data."""
    return len(stats_data["ReadInfosForLanes"])


def get_flow_cell_name(stats_data) -> str:
    """Extract the flow cell name from the stats data."""
    return stats_data["Flowcell"]


def get_sample_id(demux_result):
    """Extract the sample id from a demultiplexing result."""
    return demux_result["SampleId"]


def get_number_of_reads_for_sample_in_lane(demux_result):
    """Extract the number of reads for a sample in a lane."""
    return demux_result["NumberReads"]


def get_lane_number(conversion_result):
    """Extract the lane number from a conversion result."""
    return conversion_result["LaneNumber"]


def get_yield_q30(lane_read_metrics):
    """Extract the yield Q30 from the read metrics."""
    return lane_read_metrics["YieldQ30"]


def get_lane_yield_in_bases(conversion_result):
    """Extract the yield from the read metrics."""
    return conversion_result["Yield"]


def get_total_clusters_passing_filter(conversion_result):
    """Extract the total clusters passing the filter from the conversion result."""
    return conversion_result["TotalClustersPF"]


def get_total_raw_clusters(conversion_result):
    """Extract the total number of clusters initially generated, regardless of quality."""
    return conversion_result["TotalClustersRaw"]


def get_quality_score(read_metric):
    """Extract the sum of quality scores of all the bases from the read metrics."""
    return read_metric["QualityScoreSum"]


def get_lane_yield_q30_values(demux_result):
    """Extract the yield Q30 values for the lane from the read metrics."""
    lane_read_metrics = get_read_metrics(demux_result)
    return [get_yield_q30(metric) for metric in lane_read_metrics]


def get_lane_yield_values(demux_result):
    lane_read_metrics = get_read_metrics(demux_result)
    return [get_lane_yield_in_bases(metric) for metric in lane_read_metrics]


def get_lane_read_quality_score_values(demux_result):
    """Extract the quality score values for the lane from the read metrics."""
    lane_read_metrics = get_read_metrics(demux_result)
    return [get_quality_score(read_metric) for read_metric in lane_read_metrics]


def get_perfect_reads_for_lane(demux_result):
    """Extract the number of perfect reads for the lane from the read metrics."""
    lane_index_metrics = get_index_metrics(demux_result)
    counts = lane_index_metrics["MismatchCounts"]
    return int(counts.get("0", 0))


def calculate_aggregate_lane_read_quality_score(lane_read_quality_score_values):
    return sum(lane_read_quality_score_values)


def calculate_total_yield_q30(lane_yield_q30_values):
    """Calculate the aggregated Q30 yield for the lane from its yield Q30 values."""
    return sum(lane_yield_q30_values)


def calculate_total_lane_yield(lane_yield_values):
    """Calculate the aggregated yield for the lane from its yield values."""
    return sum(lane_yield_values)


def calculate_lane_yield_in_megabases(lane_yield_in_bases: int) -> int:
    """
    Calculate the lane yield in megabases.

    Args:
        lane_yield_in_bases (int): The total yield of the lane in bases.

    Returns:
        int: The yield in megabases.
    """
    return lane_yield_in_bases // 1000000


def calculate_passed_filter_percent(
    total_lane_clusters_passing_filter: int, total_lane_clusters_raw: int
) -> float:
    """
    Calculate the passed filter percent for the lane.

    Args:
        total_lane_clusters_passing_filter (int): The total clusters passing the filter for the lane.
        total_lane_raw_clusters (int): The total number of clusters initially generated for the lane.

    Returns:
        float: The passed filter percent.
    """
    return total_lane_clusters_passing_filter / total_lane_clusters_raw


def calculate_raw_clusters_per_lane_percent(total_raw_clusters: int, number_of_lanes: int) -> float:
    """
    Calculate the raw clusters per lane percent.

    Args:
        total_raw_clusters (int): The total number of clusters initially generated, regardless of quality.
        number_of_lanes (int): The total number of lanes.

    Returns:
        float: The raw clusters per lane percent.
    """
    return total_raw_clusters / number_of_lanes


def calculate_bases_with_q30_percent(yield_q30_total: int, yield_total: int) -> float:
    """
    Calculate the proportion of bases that have a Phred quality score of 30 or more for the lane.

    Args:
        yield_q30_total (int): The sum of all Q30 yields for samples in the lane.
        yield_total (int): The total yield for the lane.

    Returns:
        float: The proportion of bases with Q30 in the lane.
    """
    return yield_q30_total / yield_total


def calculate_lane_mean_quality_score(quality_score_sum_total: int, yield_total: int) -> float:
    """
    Calculate the mean quality score of all the bases for the lane.

    Args:
        quality_score_sum_total (int): The aggregated quality score sum for the lane.
        yield_total (int): The total yield for the lane.
    Returns:
        float: The mean quality score of all the bases for the lane.
    """
    return quality_score_sum_total / yield_total


def calculate_perfect_index_reads_percent(perfect_reads: int, total_reads: int) -> float:
    """
    Calculate the perfect index reads percentage.

    Args:
        perfect_reads (int): The number of perfect reads for a sample in a lane.
        total_reads (int): The total number of reads for a sample in a lane.

    Returns:
        float: The perfect index reads percentage.
    """
    return (perfect_reads / total_reads) * 100
