"""This module contains utility functions for parsing the metrics files generated by the BCLConvert tool."""

from pydantic import BaseModel
from typing import List


class BclConvertMetrics(BaseModel):
    """Gather metric from the BCL convert for a sample"""

    def __init__(
        self,
        sample_internal_id: str,
        flow_cell_name: str,
        lane: int,
        reads: int,
        perfect_reads: int,
        one_mismatch_reads: int,
        pass_filter_q30: int,
        mean_quality_score: float,
        r1_sample_bases: int,
        r2_sample_bases: int,
        read_length: int,
    ):
        self.sample_internal_id: str = sample_internal_id
        self.flow_cell_name: str = flow_cell_name
        self.lane: int = lane
        self.reads: int = reads
        self.perfect_reads: int = perfect_reads
        self.one_mismatch_reads: int = one_mismatch_reads
        self.pass_filter_q30: int = pass_filter_q30
        self.mean_quality_score: float = mean_quality_score
        self.r1_sample_bases: int = r1_sample_bases
        self.r2_sample_bases: int = r2_sample_bases
        self.read_length: int = read_length

    def _calculate_perfect_index_reads_pct(self) -> float:
        """calculates the percentage of perfect index reads"""
        return round(self.perfect_reads / self.reads * 100, 2) if self.reads else 0

    def _calculate_q30_bases_pct(self) -> float:
        """calculates the percentage of bases with a sequencing quality score of 30 or over"""
        return (
            round(
                self.pass_filter_q30 / (self.r1_sample_bases + self.r2_sample_bases) * 100,
                2,
            )
            if self.r1_sample_bases + self.r2_sample_bases
            else 0
        )

    def _calculate_yield(self) -> float:
        """calculates the amount of data produced in MB"""
        total_reads = self._calculate_read_counts()
        return round(total_reads * self.read_length / 1000000, 0)

    def _calculate_read_counts(self) -> int:
        """calculates the number of reads from the number of clusters"""
        return self.reads * 2
